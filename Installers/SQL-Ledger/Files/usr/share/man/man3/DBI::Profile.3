.\" Automatically generated by Pod::Man version 1.02
.\" Tue Jun 25 07:41:04 2002
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "DBI::Profile 3"
.TH DBI::Profile 3 "perl v5.6.0" "2002-06-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1DBI:\s0:Profile \- Performance profiling and benchmarking for the \s-1DBI\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI;
.Ve
.Vb 1
\&  $h->{Profile} = ... ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DBI:\s0:Profile is new and experimental and subject to change.
.PP
The \s-1DBI:\s0:Profile module provides a simple interface to collect and
report performance and benchmarking data from the \s-1DBI\s0.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Performance data collection for the \s-1DBI\s0 is built around several
concepts which are important to understand clearly.
.Ip "Method Dispatch" 4
.IX Item "Method Dispatch"
Every method call on a \s-1DBI\s0 handle passes through a single 'dispatch'
function which manages all the common aspects of \s-1DBI\s0 method calls,
such as handling the RaiseError attribute.
.Ip "Data Collection" 4
.IX Item "Data Collection"
If profiling is enabled for a handle then the dispatch code takes
a high-resolution timestamp soon after it is entered. Then, after
calling the appropriate method and just before returning, it takes
another high-resolution timestamp and calls a function to record
the information.  That function is passed the two timestamps
plus the \s-1DBI\s0 handle and the name of the method that was called.
That information about a single \s-1DBI\s0 method call is called the
\&\fIprofile sample\fR data.
.Ip "Data Filtering" 4
.IX Item "Data Filtering"
If the method call was invoked by the \s-1DBI\s0 or by a driver then the
call is currently ignored for profiling because the time spent will
be accounted for by the original 'outermost' call.
.Sp
For example, the calls that the \fIselectrow_arrayref()\fR method makes
to \fIprepare()\fR and \fIexecute()\fR etc. are not counted individually
because the time spent in those methods is going to be allocated
to the \fIselectrow_arrayref()\fR method when it returns. If this was not
done then it would be very easy to double count time spent inside
the \s-1DBI\s0.
.Sp
In future releases it may be possible to alter this behaviour.
.Ip "Data Storage Tree" 4
.IX Item "Data Storage Tree"
The profile data is stored as 'leaves on a tree'. The 'path' through
the branches of the tree to the particular leaf that will store the
profile sample data for a profiled call is determined dynamically.
This is a powerful feature.
.Sp
For example, if the Path is
.Sp
.Vb 1
\&  [ 'foo', 'bar', 'baz' ]
.Ve
then the new profile sample data will be \fImerged\fR into the tree at
.Sp
.Vb 1
\&  $h->{Profile}->{Data}->{foo}->{bar}->{baz}
.Ve
It wouldn't be very useful to merge all the call data into one leaf
node (except to get an overall 'time spent inside the \s-1DBI\s0' total).
It's more common to want the Path to include the current statement
text and/or the name of the method called to show what the time
spent inside the \s-1DBI\s0 was for.
.Sp
The Path can contain some 'magic cookie' values that are automatically
replaced by corresponding dynamic values when they're used.
For example DBIprofile_Statement (exported by \s-1DBI:\s0:profile) is
automatically replaced by value of the \f(CW\*(C`Statement\*(C'\fR attribute of
the handle. For example, is the Path was:
.Sp
.Vb 1
\&  [ 'foo', DBIprofile_Statement, 'bar' ]
.Ve
and the value of \f(CW$h\fR->{Statement} was:
.Sp
.Vb 1
\&  SELECT * FROM tablename
.Ve
then the profile data will be merged into the tree at:
.Sp
.Vb 1
\&  $h->{Profile}->{Data}->{foo}->{SELECT * FROM tablename}->{bar}
.Ve
The default Path is just \f(CW\*(C`[ DBIprofile_Statement ]\*(C'\fR and so by
default the profile data is aggregated per distinct Statement string.
.Sp
For statement handles this is always simply the string that was
given to \fIprepare()\fR when the handle was created.  For database handles
this is the statement that was last prepared or executed on that
database handle. That can lead to a little 'fuzzyness' because, for
example, calls to the \fIquote()\fR method to build a new statement will
typically be associated with the previous statement. In practice
this isn't a significant issue and the dynamic Path mechanism can
be used to setup your own rules.
.Ip "Profile Data" 4
.IX Item "Profile Data"
Profile data is stored at the 'leaves' of the tree as references
to an array of numeric values. For example:
.Sp
.Vb 9
\&    [
\&      106,                    # count
\&      0.0312958955764771,     # total duration
\&      0.000490069389343262,   # first duration
\&      0.000176072120666504,   # shortest duration
\&      0.00140702724456787,    # longest duration
\&      1023115819.83019,       # time of first event
\&      1023115819.86576,       # time of last event
\&    ]
.Ve
.SH "ENABLING A PROFILE"
.IX Header "ENABLING A PROFILE"
Profiling is enabled for a handle by assigning to the Profile
attribute. For example:
.PP
.Vb 1
\&  $h->{Profile} = DBI::Profile->new();
.Ve
The Profile attribute holds a blessed reference to a hash object
that contains the profile data and attributes relating to it.
The class the Profile object is blessed into is expected to
provide at least a \s-1DESTROY\s0 method which will dump the profile data
to the \s-1DBI\s0 trace file handle (\s-1STDERR\s0 by default).
.PP
All these examples have the same effect as the first:
.PP
.Vb 4
\&  $h->{Profile} = {};
\&  $h->{Profile} = "DBI::Profile";
\&  $h->{Profile} = "2/DBI::Profile";
\&  $h->{Profile} = 2;
.Ve
If a non-blessed hash reference is given then the \s-1DBI:\s0:Profile
module is automatically \f(CW\*(C`require\*(C'\fR'd and the reference is blessed
into that class.
.PP
If a string is given then it is split on '\f(CW\*(C`/\*(C'\fR' characters and the
first value is used to select the Path to be used (see below).
The second value, if present, is used as the name of a module which
will be loaded and it's \f(CW\*(C`new\*(C'\fR method called. If not present it
defaults to \s-1DBI:\s0:Profile. Any other values are passed as arguments
to the \f(CW\*(C`new\*(C'\fR method. For example: "\f(CW\*(C`2/DBIx::OtherProfile/Foo/42\*(C'\fR".
.PP
Various common sequences for Path can be selected by simply assigning
an integer value to Profile. The simplest way to explain how the
values are interpreted is to show the code:
.PP
.Vb 4
\&    push @Path, "DBI"                       if $path & 0x01;
\&    push @Path, DBIprofile_Statement        if $path & 0x02;
\&    push @Path, DBIprofile_MethodName       if $path & 0x04;
\&    push @Path, DBIprofile_MethodClass      if $path & 0x08;
.Ve
So using the value "\f(CW\*(C`1\*(C'\fR" causes all profile data to be merged into
a single leaf of the tree. That's useful when you just want a total.
.PP
Using "\f(CW\*(C`2\*(C'\fR" causes profile sample data to be merged grouped by
the corresponding Statement text. This is the most frequently used.
.PP
Using "\f(CW\*(C`4\*(C'\fR\*(L" causes profile sample data to be merged grouped by
the method name ('\s-1FETCH\s0', 'prepare' etc.). Using \*(R"\f(CW\*(C`8\*(C'\fR" is similar
but gives the fully qualified 'glob name' of the method called. For
example: '*DBD::Driver::db::prepare', '*DBD::_::st::fetchrow_hashref'.
.PP
The values can be added together to create deeper paths. The most
useful being 6 (statement then method name) or 10 (statement then
method name with class).  Using a negative number will reverse the
path. Thus \-6 will group by method name then statement.
.PP
The spliting and parsing of string values assigned to the Profile
attribute may seem a little odd, but there's a good reason for it.
Remember that attributes can be embedded in the Data Source Name
string which can be passed in to a script as a parameter. For
example:
.PP
.Vb 1
\&    dbi:DriverName(RaiseError=>1,Profile=>2):dbname
.Ve
And also, if the \f(CW\*(C`DBI_PROFILE\*(C'\fR environment variable is set then
The \s-1DBI\s0 arranges for every driver handle to share the same profile
object. When perl exits a single profile summary will be generated
that reflects (as nearly as practical) the total use of the \s-1DBI\s0 by
the application.
.SH "THE PROFILE OBJECT"
.IX Header "THE PROFILE OBJECT"
The \s-1DBI\s0 core expects the Profile attribute value to be a hash
reference and if the following values don't exist it will create
them as needed:
.Sh "Data"
.IX Subsection "Data"
A reference to a hash containing the collected profile data.
.Sh "Path"
.IX Subsection "Path"
The Path value is used to control where the profile for a method
call will be merged into the collected profile data.  Whenever
profile data is to be stored the current value for Path is used.
.PP
The value can be one of:
.Ip "Array Reference" 4
.IX Item "Array Reference"
Each element of the array defines an element of the path to use to
store the profile data into the \f(CW\*(C`Data\*(C'\fR hash.
.Ip "Undefined value (the default)" 4
.IX Item "Undefined value (the default)"
Treated the same as \f(CW\*(C`[ $DBI::Profile::DBIprofile_Statement ]\*(C'\fR.
.Ip "Subroutine Reference \fB\s-1NOT\s0 \s-1YET\s0 \s-1IMPLEMENTED\s0\fR" 4
.IX Item "Subroutine Reference NOT YET IMPLEMENTED"
The subroutine is passed the \s-1DBI\s0 method name and the handle it was
called on.  It should return a list of values to uses as the path.
If it returns an empty list then the method call is not profiled.
.PP
The following 'magic cookie' values can be included in the Path and will be
.Ip "DBIprofile_Statement" 4
.IX Item "DBIprofile_Statement"
Replaced with the current value of the Statement attribute for the
handle the method was called with. If that value is undefined then
an empty string is used.
.Ip "DBIprofile_MethodName" 4
.IX Item "DBIprofile_MethodName"
Replaced with the name of the \s-1DBI\s0 method that the profile sample
relates to.
.Ip "DBIprofile_MethodClass" 4
.IX Item "DBIprofile_MethodClass"
Replaced with the fully qualified name of the \s-1DBI\s0 method, including
the package, that the profile sample relates to. This shows you
where the method was implemented. For example:
.Sp
.Vb 4
\&  'DBD::_::db::selectrow_arrayref' =>
\&      0.022902s
\&  'DBD::mysql::db::selectrow_arrayref' =>
\&      2.244521s / 99 = 0.022445s avg (first 0.022813s, min 0.022051s, max 0.028932s)
.Ve
The \*(L"\s-1DBD::_:\s0:db::selectrow_arrayref\*(R" shows that the driver has
inherited the selectrow_arrayref method provided by the \s-1DBI\s0.
.Sp
But you'll note that there is only one call to
\&\s-1DBD::_:\s0:db::selectrow_arrayref but another 99 to
\&\s-1DBD:\s0:mysql::db::selectrow_arrayref. That's because after the first
call Perl has cached the method to speed up method calls.
You may also see some names begin with an asterix ('\f(CW\*(C`*\*(C'\fR').
Both of these effects are subject to change in later releases.
.PP
Other magic cookie values may be added in the future.
.SH "REPORTING"
.IX Header "REPORTING"
.Sh "Report Format"
.IX Subsection "Report Format"
The current profile data can be formatted and output using
.PP
.Vb 1
\&    print $h->{Profile}->format;
.Ve
To discard the profile data and start collecting fresh data
you can do:
.PP
.Vb 1
\&    $h->{Profile}->{Data} = undef;
.Ve
The default results format looks like this:
.PP
.Vb 5
\&  DBI::Profile: 0.001015 seconds (5 method calls) programname
\&  '' =>
\&      0.000024s / 2 = 0.000012s avg (first 0.000015s, min 0.000009s, max 0.000015s)
\&  'SELECT mode,size,name FROM table' =>
\&      0.000991s / 3 = 0.000330s avg (first 0.000678s, min 0.000009s, max 0.000678s)
.Ve
Which shows the total time spent inside the \s-1DBI\s0, with a count of
the total number of method calls and the name of the script being
run, then a formated version of the profile data tree.
.PP
If the results are being formated when the perl process is exiting
(which is usually the case when the \s-1DBI_PROFILE\s0 environment variable
is used) then the percentage of time the process spent inside the
\&\s-1DBI\s0 is also shown.
.PP
In the example above the paths in the tree are only one level deep and
use the Statement text as the value (that's the default behaviour).
.PP
The merged profile data at the 'leaves' of the tree are presented
as total time spent, count, average time spent (which is simply total
time divided by the count), then the time spent on the first call,
the time spent on the fastest call, and finally the time spent on
the slowest call.
.PP
The 'avg', 'first', 'min' and 'max' times are not particularly
useful when the profile data path only contains the statement text.
Here's an extract of a more detailed example using both statement
text and method name in the path:
.PP
.Vb 5
\&  'SELECT mode,size,name FROM table' =>
\&      'FETCH' =>
\&          0.000076s
\&      'fetchrow_hashref' =>
\&          0.036203s / 108 = 0.000335s avg (first 0.000490s, min 0.000152s, max 0.002786s)
.Ve
Here you can see the 'avg', 'first', 'min' and 'max' for the
108 calls to \fIfetchrow_hashref()\fR become rather more interesting.
Also the data for \s-1FETCH\s0 just shows a time value because it was only
called once.
.PP
Currently the profile data is output sorted by branch names. That
may change in a later version so the leaf nodes are sorted by total
time per leaf node.
.Sh "Report Destination"
.IX Subsection "Report Destination"
The default method of reporting is for the \s-1DESTROY\s0 method of the
Profile object to format the results and write them using:
.PP
.Vb 1
\&    DBI->trace_msg($results, 0)
.Ve
to write them to the \s-1DBI\s0 \fItrace()\fR filehandle (which defaults to
\&\s-1STDERR\s0). To direct the \s-1DBI\s0 trace filehandle to write to a file
without enabling tracing the \fItrace()\fR method can be called with a
trace level of 0. For example:
.PP
.Vb 1
\&    DBI->trace(0, $filename);
.Ve
The same effect can be achieved without changing the code by
setting the \f(CW\*(C`DBI_TRACE\*(C'\fR environment variable to \f(CW\*(C`0=filename\*(C'\fR.
.SH "CHILD HANDLES"
.IX Header "CHILD HANDLES"
Child handles inherit a reference to the Profile attribute value
of their parent.  So if profiling is enabled for a database handle
then by default the statement handles created from it all contribute
to the same merged profile data tree.
.SH "CUSTOM DATA COLLECTION"
.IX Header "CUSTOM DATA COLLECTION"
.Sh "Using The Path Attribute"
.IX Subsection "Using The Path Attribute"
.Vb 6
\&  XXX example to be added later using a selectall_arrayref call
\&  XXX nested inside a fetch loop where the first column of the
\&  XXX outer loop is bound to the profile Path using
\&  XXX bind_column(1, \e${ $dbh->{Profile}->{Path}->[0] })
\&  XXX so you end up with separate profiles for each loop
\&  XXX (patches welcome to add this to the docs :)
.Ve
.Sh "Adding Your Own Samples"
.IX Subsection "Adding Your Own Samples"
The \fIdbi_profile()\fR function can be used to add extra sample data
into the profile data tree. For example:
.PP
.Vb 3
\&    use DBI;
\&    use DBI::Profile (dbi_profile);
\&    use Time::HiRes qw(gettimeofday);
.Ve
.Vb 1
\&    my $t1 = gettimeofday;
.Ve
.Vb 1
\&    ... execute code you want to profile here ...
.Ve
.Vb 2
\&    my $t2 = gettimeofday;
\&    dbi_profile($h, $statement, $method, $t1, $t2);
.Ve
The \f(CW$h\fR parameter is the handle the extra profile sample should be
associated with. The \f(CW$statement\fR parameter is the string to use where
the Path specifies DBIprofile_Statement. If \f(CW$statement\fR is undef
then \f(CW$h\fR->{Statement} will be used. Similarly \f(CW$method\fR is the string
to use if the Path specifies DBIprofile_MethodName. There is no
default value for \f(CW$method\fR.
.PP
The \f(CW$h\fR->{Path} attribute is processed by \fIdbi_profile()\fR in the usual way.
.PP
It is recommended that you keep these extra data samples separate
from the \s-1DBI\s0 profile data samples by using values for \f(CW$statement\fR
and \f(CW$method\fR that are distinct from any that are likely to appear
in the profile data normally.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Alternate profile modules must subclass \s-1DBI:\s0:Profile to help ensure
they work with future versions of the \s-1DBI\s0.
.SH "CAVEATS"
.IX Header "CAVEATS"
Applications which generate many different statement strings
(typically because they don't use placeholders) and profile with
DBIprofile_Statement in the Path (the default) will consume memory
in the Profile Data structure for each statement.
.PP
If a method throws an exception itself (not via RaiseError) then
it won't be counted in the profile.
.PP
If a HandleError subroutine throws an exception, rather than returning
0 and letting RaiseError do it, then the method call won't be counted
in the profile.
.PP
Time spent in \s-1DESTROY\s0 is currently not counted.
.PP
Time spent in \s-1DBI-\s0>*() methods is not counted. The time spent in
the driver connect method, \f(CW$drh\fR->\fIconnect()\fR, when it's called by
\&\s-1DBI-\s0>connect is counted if the \s-1DBI_PROFILE\s0 environment variable is set.
.PP
\&\s-1DBI:\s0:PurePerl does not support profiling (though it could in theory).
.PP
A few platforms don't support the \fIgettimeofday()\fR high resolution
time function used by the \s-1DBI\s0. In which case you'll get integer
resolution time which are mostly useless.
.PP
This documentation could be more clear. Probably needs to be reordered
to start with several examples and build from there.  Trying to
explain the concepts first seems to lead to many forward references.
(Patches welcome.)
