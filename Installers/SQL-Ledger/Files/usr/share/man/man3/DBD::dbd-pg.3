.\" Automatically generated by Pod::Man version 1.02
.\" Tue Jun 25 07:42:14 2002
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "DBD-PG 1"
.TH DBD-PG 1 "perl v5.6.0" "2002-03-06" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1DBD:\s0:Pg \- PostgreSQL database driver for the \s-1DBI\s0 module
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DBD:\s0:Pg is a Perl module which works with the \s-1DBI\s0 module to provide
access to PostgreSQL databases.
.SH "DBD::Pg"
.IX Header "DBD::Pg"
.SH ""
.IX Header ""
.Sh "Version"
.IX Subsection "Version"
Version 0.91.
.Sh "Author and Contact Details"
.IX Subsection "Author and Contact Details"
The driver author is Edmund Mergl.  He can be contacted via the
\&\fIdbi-users\fR mailing list.
.Sh "Supported Database Versions and Options"
.IX Subsection "Supported Database Versions and Options"
The DBD-Pg-0.92 module supports Postgresql 6.5.
.Sh "Connect Syntax"
.IX Subsection "Connect Syntax"
The \f(CW\*(C`DBI\->connect()\*(C'\fR Data Source Name, or \fI\s-1DSN\s0\fR, can be one of the
following:
.PP
.Vb 2
\&  dbi:Pg:dbname=$dbname
\&  dbi:Pg:dbname=$dbname;host=$host;port=$port;options=$options;tty=$tty
.Ve
All parameters, including the userid and password parameter of the 
connect command, have a hard-coded default which can be overridden 
by setting appropriate environment variables:
.PP
.Vb 9
\&  Parameter  Environment Variable  Default
\&  ---------  --------------------  --------------
\&  dbname     PGDATABASE            current userid
\&  host       PGHOST                localhost
\&  port       PGPORT                5432
\&  options    PGOPTIONS             ""
\&  tty        PGTTY                 ""
\&  username   PGUSER                current userid
\&  password   PGPASSWORD            ""
.Ve
There are no driver specific attributes for the \f(CW\*(C`DBI\-\*(C'\fR\fIconnect()\fR> method.
.Sh "Numeric Data Handling"
.IX Subsection "Numeric Data Handling"
Postgresql supports the following numeric types:
.PP
.Vb 6
\&  Postgresql     Range
\&  ----------     --------------------------
\&  int2           -32768 to +32767
\&  int4           -2147483648 to +2147483647
\&  float4         6 decimal places
\&  float8         15 decimal places
.Ve
Some platforms also support the int8 type.
\&\f(CW\*(C`DBD::Pg\*(C'\fR always returns all numbers as strings.
.Sh "String Data Handling"
.IX Subsection "String Data Handling"
Postgresql supports the following string data types:
.PP
.Vb 4
\&  CHAR            single character
\&  CHAR(size)      fixed length blank-padded
\&  VARCHAR(size)   variable length with limit
\&  TEXT            variable length
.Ve
All string data types have a limit of 4096 bytes. 
The \s-1CHAR\s0 type is fixed length and blank padded.
.PP
There is no special handling for data with the 8th bit set. They
are stored unchanged in the database. 
None of the character types can store embedded nulls and Unicode is
not formally supported.
.PP
Strings can be concatenated using the \f(CW\*(C`||\*(C'\fR operator.
.Sh "Date Data Handling"
.IX Subsection "Date Data Handling"
Postgresql supports the following date time data types:
.PP
.Vb 10
\&  Type       Storage   Recommendation              Description
\&  ---------  --------  --------------------------  ----------------------------
\&  abstime     4 bytes  original date and time      limited range
\&  date        4 bytes  SQL92 type                  wide range
\&  datetime    8 bytes  best general date and time  wide range, high precision
\&  interval   12 bytes  SQL92 type                  equivalent to timespan
\&  reltime     4 bytes  original time interval      limited range, low precision
\&  time        4 bytes  SQL92 type                  wide range
\&  timespan   12 bytes  best general time interval  wide range, high precision
\&  timestamp   4 bytes  SQL92 type                  limited range
.Ve
.Vb 10
\&  Data Type    Range                               Resolution
\&  ----------   ----------------------------------  -----------
\&  abstime      1901-12-14        2038-01-19        1 sec
\&  timestamp    1901-12-14        2038-01-19        1 sec
\&  reltime      -68 years         +68 years         1 sec
\&  tinterval    -178000000 years  +178000000 years  1 microsec
\&  timespan     -178000000 years  178000000 years   1 microsec
\&  date         4713 BC             32767 AD        1 day
\&  datetime     4713 BC           1465001 AD        1 microsec
\&  time         00:00:00:00       23:59:59:99       1 microsec
.Ve
Postgresql supports a range of date formats:
.PP
.Vb 8
\&  Name           Example
\&  -----------    ----------------------
\&  ISO            1997-12-17 0:37:16-08
\&  SQL            12/17/1997 07:37:16.00 PST
\&  Postgres       Wed Dec 17 07:37:16 1997 PST
\&  European       17/12/1997 15:37:16.00 MET
\&  NonEuropean    12/17/1997 15:37:16.00 MET
\&  US             12/17/1997 07:37:16.00 MET
.Ve
The default output format does not depend on the client/server locale.
It depends on, in increasing priority: the \s-1PGDATESTYLE\s0 environment
variable at the server, the \s-1PGDATESTYLE\s0 environment variable at the client, and
the \f(CW\*(C`SET DATESTYLE\*(C'\fR \s-1SQL\s0 command.
.PP
All of the formats described above can be used for input. A great many
others can also be used. There is no specific default input format.
If the format of a date input is ambiguous then the current \s-1DATESTYLE\s0
is used to help disambiguate.
.PP
If you specify a date/time value without a time component, the default 
time is 00:00:00 (midnight). To specify a date/time value without a date 
is not allowed. 
If a date with a two digit year is input then if the year was less than
70, add 2000; otherwise, add 1900.
.PP
The currect date/time is returned by the keyword \f(CW\*(C`'now'\*(C'\fR or \f(CW\*(C`'current'\*(C'\fR,
which has to be casted to a valid data type. For example:
.PP
.Vb 1
\&  SELECT 'now'::datetime
.Ve
Postgresql supports a range of date time functions for converting
between types, extracting parts of a date time value, truncating to a
given unit, etc. The usual arithmetic can be performed on date and
interval values, e.g., date-date=interval, etc.
.PP
The following \s-1SQL\s0 expression can be used to convert an integer \*(L"seconds
since 1\-jan-1970 \s-1GMT\s0\*(R" value to the corresponding database date time:
.PP
.Vb 1
\&  DATETIME(unixtime_field)
.Ve
and to do the reverse:
.PP
.Vb 1
\&  DATE_PART('epoch', datetime_field)
.Ve
The server stores all dates internally in \s-1GMT\s0.  Times are converted to
local time on the database server before being sent to the client
frontend, hence by default are in the server time zone.
.PP
The \s-1TZ\s0 environment variable is used by the server as default time
zone.  The \s-1PGTZ\s0 environment variable on the client side is used to send
the time zone information to the backend upon connection. The \s-1SQL\s0 \f(CW\*(C`SET
TIME ZONE\*(C'\fR command can set the time zone for the current session.
.Sh "\s-1LONG/BLOB\s0 Data Handling"
.IX Subsection "LONG/BLOB Data Handling"
Postgresql handles \s-1BLOBS\s0 using a so called \*(L"large objects\*(R" type. The
handling of this type differs from all other data types. The data are
broken into chunks, which are stored in tuples in the database. Access
to large objects is given by an interface which is modelled closely
after the \s-1UNIX\s0 file system. The maximum size is limited by the file
size of the operating system.
.PP
If you just select the field, you get a \*(L"large object identifier\*(R" and
not the data itself. The \fILongReadLen\fR and \fILongTruncOk\fR attributes are
not implemented because they don't make sense in this case. The only
method implemented by the driver is the undocumented \s-1DBI\s0 method
\&\f(CW\*(C`blob_read()\*(C'\fR.
.Sh "Other Data Handling issues"
.IX Subsection "Other Data Handling issues"
The \f(CW\*(C`DBD::Pg\*(C'\fR driver supports the \f(CW\*(C`type_info()\*(C'\fR method.
.PP
Postgresql supports automatic conversions between data types wherever
it's reasonable.
.Sh "Transactions, Isolation and Locking"
.IX Subsection "Transactions, Isolation and Locking"
Postgresql supports transactions.
The current default isolation transaction level is \*(L"Serializable\*(R" and
is currently implemented using table level locks. Both may change.
No other isolation levels for transactions are supported.
.PP
With AutoCommit on, a query never places a lock on a table. Readers
never block writers and writers never block readers. This behavior
changes whenever a transaction is started (AutoCommit off). Then a
query induces a shared lock on a table and blocks anyone else
until the transaction has been finished.
.PP
The \f(CW\*(C`LOCK TABLE table_name\*(C'\fR statement can be used to apply an explicit
lock on a table. This only works inside a transaction (AutoCommit off).
.PP
To ensure that a table being selected does not change before you make
an update later in the transaction, you must explicitly lock it with a
\&\f(CW\*(C`LOCK TABLE\*(C'\fR statement before executing the select.
.Sh "No-Table Expression Select Syntax"
.IX Subsection "No-Table Expression Select Syntax"
To select a constant expression, that is, an expression that doesn't involve
data from a database table or view, just omit the \*(L"from\*(R" clause.
Here's an example that selects the current time as a datetime:
.PP
.Vb 1
\&  SELECT 'now'::datetime;
.Ve
.Sh "Table Join Syntax"
.IX Subsection "Table Join Syntax"
Outer joins are not supported. Inner joins use the traditional syntax.
.Sh "Table and Column Names"
.IX Subsection "Table and Column Names"
The max size of table and column names cannot exceed 31 charaters in
length.
Only alphanumeric characters can be used; the first character must
be a letter.
.PP
If an identifier is enclosed by double quotation marks (\f(CW\*(C`"\*(C'\fR), it can
contain any combination of characters except double quotation marks.
.PP
Postgresql converts all identifiers to lower-case unless enclosed in
double quotation marks.
National character set characters can be used, if enclosed in quotation
marks.
.Sh "Case Sensitivity of \s-1LIKE\s0 Operator"
.IX Subsection "Case Sensitivity of LIKE Operator"
Postgresql has the following string matching operators:
.PP
.Vb 8
\& Glyph Description                                Example
\& ----- ----------------------------------------   -----------------------------
\& ~~    Same as SQL "LIKE" operator                'scrappy,marc' ~~ '%scrappy%'
\& !~~   Same as SQL "NOT LIKE" operator            'bruce' !~~ '%al%'
\& ~     Match (regex), case sensitive              'thomas' ~ '.*thomas.*'
\& ~*    Match (regex), case insensitive            'thomas' ~* '.*Thomas.*'
\& !~    Does not match (regex), case sensitive     'thomas' !~ '.*Thomas.*'
\& !~*   Does not match (regex), case insensitive   'thomas' !~ '.*vadim.*'
.Ve
.Sh "Row \s-1ID\s0"
.IX Subsection "Row ID"
The Postgresql \*(L"row id\*(R" pseudocolumn is called \fIoid\fR, object identifier.
It can be treated as a string and used to rapidly (re)select rows.
.Sh "Automatic Key or Sequence Generation"
.IX Subsection "Automatic Key or Sequence Generation"
Postgresql does not support automatic key generation such as \*(L"auto
increment\*(R" or \*(L"system generated\*(R" keys.
.PP
However, Postgresql does support \*(L"sequence generators\*(R". Any number of
named sequence generators can be created in a database. Sequences 
are used via functions called \f(CW\*(C`NEXTVAL\*(C'\fR and \f(CW\*(C`CURRVAL\*(C'\fR. Typical usage:
.PP
.Vb 1
\&  INSERT INTO table (k, v) VALUES (nextval('seq_name'), ?);
.Ve
To get the value just inserted, you can use the corresponding \f(CW\*(C`currval()\*(C'\fR
\&\s-1SQL\s0 function in the same session, or
.PP
.Vb 1
\&  SELECT last_value FROM seq_name
.Ve
.Sh "Automatic Row Numbering and Row Count Limiting"
.IX Subsection "Automatic Row Numbering and Row Count Limiting"
Postgresql does not support any way of automatically numbering returned rows.
.Sh "Parameter Binding"
.IX Subsection "Parameter Binding"
Parameter binding is emulated by the driver.
Both the \f(CW\*(C`?\*(C'\fR and \f(CW\*(C`:1\*(C'\fR style of placeholders are supported.
.PP
The \s-1TYPE\s0 attribute of the \f(CW\*(C`bind_param()\*(C'\fR method may be used to
influence how parameters are treated. These \s-1SQL\s0 types are bound as
\&\s-1VARCHAR:\s0 \s-1SQL_NUMERIC\s0, \s-1SQL_DECIMAL\s0, \s-1SQL_INTEGER\s0, \s-1SQL_SMALLINT\s0,
\&\s-1SQL_FLOAT\s0, \s-1SQL_REAL\s0, \s-1SQL_DOUBLE\s0, \s-1SQL_VARCHAR\s0.
.PP
The \s-1SQL_CHAR\s0 type is bound as a \s-1CHAR\s0 thus enabling fixed-width blank
padded comparison semantics.
.PP
Unsupported values of the \s-1TYPE\s0 attribute generate a warning.
.Sh "Stored Procedures"
.IX Subsection "Stored Procedures"
\&\f(CW\*(C`DBD::Pg\*(C'\fR does not support stored procedures.
.Sh "Table Metadata"
.IX Subsection "Table Metadata"
\&\f(CW\*(C`DBD::Pg\*(C'\fR supports the \f(CW\*(C`table_info()\*(C'\fR method.
.PP
The \fIpg_attribute\fR table contains detailed information about all columns
of all the tables in the database, one row per table. 
.PP
The \fIpg_index\fR table contains detailed information about all indexes in
the database, one row per index.
.PP
Primary keys are implemented as unique indexes. See \fIpg_index\fR above.
.Sh "Driver-specific Attributes and Methods"
.IX Subsection "Driver-specific Attributes and Methods"
There are no significant \f(CW\*(C`DBD::Pg\*(C'\fR driver-specific database handle attributes.
.PP
\&\f(CW\*(C`DBD::Pg\*(C'\fR has the following driver-specific statement handle attributes:
.Ip "\fIpg_size\fR" 8
.IX Item "pg_size"
Returns a reference to an array of integer values for each column. The
integer shows the storage (not display) size of the column in bytes.
Variable length columns are indicated by \-1.
.Ip "\fIpg_type\fR" 8
.IX Item "pg_type"
Returns a reference to an array of strings for each column. The string
shows the name of the data type.
.Ip "\fIpg_oid_status\fR" 8
.IX Item "pg_oid_status"
Returns the \s-1OID\s0 of the last \s-1INSERT\s0 command.
.Ip "\fIpg_cmd_status\fR" 8
.IX Item "pg_cmd_status"
Returns the name of the last command type. Possible types are: \s-1INSERT\s0,
\&\s-1DELETE\s0, \s-1UPDATE\s0, \s-1SELECT\s0.
.PP
\&\f(CW\*(C`DBD::Pg\*(C'\fR has no private methods.
.Sh "Positioned updates and deletes"
.IX Subsection "Positioned updates and deletes"
Postgresql does not support positioned updates or deletes.
.Sh "Differences from the \s-1DBI\s0 Specification"
.IX Subsection "Differences from the DBI Specification"
\&\f(CW\*(C`DBD::Pg\*(C'\fR has no significant differences in behavior from the
current \s-1DBI\s0 specification.
.PP
Note that \f(CW\*(C`DBD::Pg\*(C'\fR does not fully parse the statement until
it's executed. Thus attributes like \fI$sth->{\s-1NUM_OF_FIELDS\s0}\fR are not
available until after \f(CW\*(C`$sth\->execute\*(C'\fR has been called. This is valid
behaviour but is important to note when porting applications
originally written for other drivers.
.Sh "URLs to More Database/Driver Specific Information"
.IX Subsection "URLs to More Database/Driver Specific Information"
.Vb 1
\&  http://www.postgresql.org
.Ve
.Sh "Concurrent use of Multiple Handles"
.IX Subsection "Concurrent use of Multiple Handles"
\&\f(CW\*(C`DBD::Pg\*(C'\fR supports an unlimited number of concurrent database
connections to one or more databases.
.PP
It also supports the preparation and execution of a new statement
handle while still fetching data from another statement handle,
provided it is 
associated with the same database handle.
.Sh "Other Significant Database or Driver Features"
.IX Subsection "Other Significant Database or Driver Features"
Postgres offers substantial additional power by incorporating the
following four additional basic concepts in such a way that users can
easily extend the system: classes, inheritance, types, and functions.
.PP
Other features provide additional power and flexibility: constraints,
triggers, rules, transaction integrity, procedural languages, and large objects.
.PP
It's also free Open Source Software with an active community of developers.
